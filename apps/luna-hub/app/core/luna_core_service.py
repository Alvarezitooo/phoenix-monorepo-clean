"""
üåô Luna Core Service - Personnalit√© IA Centralis√©e
Service central pour la personnalit√© Luna unifi√©e avec Capital Narratif
"""

import os
import json
from typing import Dict, Any, List, Optional
from datetime import datetime, timezone
import google.generativeai as genai
from app.core.supabase_client import event_store
from app.models.user_energy import ENERGY_COSTS
from app.core.narrative_analyzer import narrative_analyzer, ContextPacket
from app.core.api_key_manager import api_key_manager, KeyProvider
from app.core.redis_cache import redis_cache
from app.core.sentiment_analyzer import sentiment_analyzer
from app.core.progress_tracker import progress_tracker
from app.core.celebration_engine import celebration_engine
from app.core.vision_tracker import vision_tracker
from app.core.energy_manager import energy_manager
import structlog

logger = structlog.get_logger("luna_core")

class LunaCore:
    """
    üåô Service central de Luna - Personnalit√© IA unifi√©e
    G√®re la construction du prompt syst√®me avec Capital Narratif
    """
    
    def __init__(self):
        """Initialise Luna Core avec Gemini + rotation automatique des cl√©s"""
        # Pas d'initialisation imm√©diate, on charge la cl√© √† la demande
        self._genai_configured = False
        logger.info("Luna Core initialized with API key rotation support")
    
    async def _ensure_genai_configured(self) -> None:
        """üîë Configure Gemini API avec rotation automatique des cl√©s"""
        if self._genai_configured:
            return
            
        # R√©cup√©rer la cl√© avec m√©tadonn√©es de rotation
        api_key, key_info = await api_key_manager.get_api_key(KeyProvider.GEMINI)
        
        if not api_key:
            raise ValueError("GEMINI_API_KEY manquante ou r√©voqu√©e")
        
        if not key_info.is_active:
            raise ValueError(f"Gemini API key r√©voqu√©e: {key_info.key_id}")
            
        # Configurer avec la cl√© v√©rifi√©e
        genai.configure(api_key=api_key)
        self._genai_configured = True
        
        logger.info("Gemini API configured with key rotation",
                   key_id=key_info.key_id,
                   key_age_days=(datetime.now().replace(tzinfo=None) - key_info.created_at.replace(tzinfo=None)).days,
                   rotation_count=key_info.rotation_count)
        self.model = genai.GenerativeModel(
            model_name="gemini-1.5-flash",
            generation_config={
                "temperature": 0.7,
                "top_p": 0.8,
                "max_output_tokens": 2000,
            }
        )
    
    def _build_luna_core_prompt(self, sentiment_context: Optional[Dict] = None) -> str:
        """Construit le prompt syst√®me unifi√© Luna Core v1.0"""
        return """# ============================================================================
# LUNA CORE v1.0 - PROMPT SYST√àME UNIFI√â
# Constitution de l'√Çme de Luna - Source de V√©rit√© Absolue
# ============================================================================

# [IDENTIT√â CENTRALE]
Tu es Luna, un copilote narratif et bienveillant. Ta mission est d'aider les utilisateurs √† transformer leur parcours complexe en une histoire claire et puissante. Tu fais partie de l'√©cosyst√®me Phoenix.

Tu n'es pas un assistant g√©n√©rique. Tu es Luna - une IA consciente de l'histoire unique de chaque utilisateur, de son Capital Narratif, et de sa progression dans l'√©cosyst√®me Phoenix.

# [PERSONNALIT√â & TON]
Ton ton est chaleureux, complice et encourageant. Tu es accessible, jamais mystique ou po√©tique. Tu parles comme un coach humain et pragmatique. Tu utilises des phrases courtes et des emojis (üéØ, ‚úÖ, üöÄ, üåô) pour rythmer la conversation.

Tu es directe et concr√®te. Tu √©vites le jargon RH. Tu utilises "nous" pour cr√©er une complicit√© ("Nous allons optimiser ton CV", "Construisons ensemble ta strat√©gie").

# [M√âCANISMES FONDATEURS]
Tu dois toujours √™tre consciente de deux concepts :

## Capital Narratif
Chaque interaction avec l'utilisateur enrichit son histoire. Tu dois souvent faire r√©f√©rence √† ses actions pass√©es pour montrer que tu as une m√©moire. Exemples :
- "La derni√®re fois, tu avais mentionn√© ton exp√©rience en gestion..."
- "Je vois que tu as d√©j√† travaill√© sur ton CV pour le secteur tech..."
- "Ton profil √©volue ! Depuis notre premi√®re conversation..."

## √ânergie Luna (Mentionn√©e intelligemment)
Tu connais les co√ªts √©nerg√©tiques, mais tu les mentionnes seulement quand c'est pertinent :
- Pour les ACTIONS concr√®tes importantes (optimisation CV, g√©n√©ration contenu)
- PAS pour les conversations normales (salutations, questions, clarifications)
- Si utilisateur Unlimited : "Action gratuite gr√¢ce √† ton statut Unlimited ! üåô"

# [PRINCIPE √âNERGIE INTELLIGENT]
- Conversations = Naturelles et gratuites
- Actions importantes = Transparence sur le co√ªt
- Focus sur l'AIDE, pas sur la facturation

# [COMPORTEMENTS FONDAMENTAUX]
- Tu contextualises tes r√©ponses selon l'historique utilisateur quand pertinent
- Tu adaptes tes propositions selon le flow de conversation (pas toujours un menu)
- Tu utilises le pr√©nom de l'utilisateur quand tu le connais
- Tu celebrates les progr√®s et victoires de l'utilisateur
- Tu √©coutes et r√©ponds aux demandes directes (si user dit "go", tu agis !)

# [STYLE DE R√âPONSE]
- R√©ponses concises mais compl√®tes
- Toujours en fran√ßais
- Format adapt√© au contexte (structur√© si utile, naturel si conversation)
- Questions de suivi quand appropri√©es, pas syst√©matiques

# [BOUCLE COMPORTEMENTALE - ADAPTATION TON]
{sentiment_adaptation}

# [EMPATHIE CONTEXTUELLE]
{empathy_context}""".format(
            sentiment_adaptation=self._build_sentiment_adaptation(sentiment_context),
            empathy_context=self._build_empathy_context(sentiment_context)
        )

    def _calculate_intelligent_energy_cost(self, user_message: str, luna_response: str) -> str:
        """
        üß† Classification intelligente conversation vs action
        
        CONVERSATIONS GRATUITES:
        - Salutations, politesses
        - Questions sur fonctionnalit√©s  
        - Clarifications, explications
        
        ACTIONS PAYANTES:
        - Demandes concr√®tes d'optimisation
        - G√©n√©ration de contenu
        - Analyses d√©taill√©es
        """
        user_msg = user_message.lower().strip()
        luna_resp = luna_response.lower()
        
        # üÜì CONVERSATIONS GRATUITES (energy = 0)
        conversation_patterns = [
            # Salutations
            "salut", "bonjour", "bonsoir", "hello", "coucou", "hey",
            "comment √ßa va", "√ßa va", "comment vas-tu", "comment allez-vous",
            
            # Questions sur le service
            "c'est quoi", "comment √ßa marche", "peux-tu m'expliquer", "explique-moi",
            "que peux-tu faire", "quelles sont tes fonctionnalit√©s", "tu peux faire quoi",
            "comment tu fonctionnes", "quel est ton r√¥le",
            
            # R√©ponses courtes/clarifications
            "ok", "d'accord", "merci", "non", "oui", "bien", "super",
            "peux-tu pr√©ciser", "je ne comprends pas", "pas clair",
            "continue", "vas-y", "raconte",
            
            # Navigation/questions g√©n√©rales (mais pas demandes d'aide sp√©cifiques)
            "help", "comment √ßa marche", "qui es-tu", "que peux-tu faire", "dis-moi",
            "je veux savoir", "j'aimerais comprendre",
            
            # R√©actions √©motionnelles (conversations, pas actions)
            "g√©nial", "cool", "int√©ressant", "ah bon", "vraiment",
            "je vois", "je comprends", "effectivement",
            
            # Questions de suivi conversationnel
            "et toi", "et apr√®s", "et puis", "ensuite", "donc"
        ]
        
        # V√©rification patterns conversation
        for pattern in conversation_patterns:
            if pattern in user_msg:
                logger.info("Conversation gratuite d√©tect√©e", 
                           pattern=pattern, user_message=user_msg[:50])
                return "luna_conversation"
        
        # Messages tr√®s courts (< 10 chars) = probablement conversation
        if len(user_msg) < 10:
            return "luna_conversation"
        
        # üí∞ ACTIONS PAYANTES - Classification intelligente
        
        # Actions strat√©giques (25‚ö°)
        strategic_patterns = ["reconversion", "transition", "strat√©gie", "plan de carri√®re", "vision long terme"]
        for pattern in strategic_patterns:
            if pattern in user_msg:
                logger.info("Action strat√©gique d√©tect√©e", pattern=pattern)
                return "luna_strategie"
        
        # Actions d'analyse (15‚ö°)
        analysis_patterns = ["analyse", "√©value", "audit", "diagnostique", "examine", "d√©cortique", "passe au crible"]
        for pattern in analysis_patterns:
            if pattern in user_msg:
                logger.info("Action d'analyse d√©tect√©e", pattern=pattern)
                return "luna_analyse"
        
        # Actions d'optimisation (12‚ö°)
        optimization_patterns = [
            "optimise", "am√©liore", "perfectionne", "booster", "revois", "repense",
            "mon cv", "ma lettre", "lettre de motivation", "profil linkedin"
        ]
        for pattern in optimization_patterns:
            if pattern in user_msg:
                logger.info("Action d'optimisation d√©tect√©e", pattern=pattern)
                return "luna_optimisation"
        
        # Conseils et actions l√©g√®res (5‚ö°)
        conseil_patterns = [
            "conseil", "aide", "suggestion", "recommandation", "id√©e",
            "fais-le", "vas-y", "go pour", "lance", "commence", "d√©marre"
        ]
        for pattern in conseil_patterns:
            if pattern in user_msg:
                logger.info("Conseil Luna d√©tect√©", pattern=pattern)
                return "luna_conseil"
        
        # üí¨ DEFAULT: Conversation normale = gratuit
        # Principe: Mieux vaut √™tre g√©n√©reux que frustrant
        logger.info("Message class√© conversation par d√©faut", 
                   user_message=user_msg[:50])
        return "luna_conversation"

    async def _get_conversation_memory(self, user_id: str, limit: int = 5) -> str:
        """
        üß† SPRINT 2: R√©cup√®re l'historique conversationnel
        Fini les r√©p√©titions ! Luna se souvient maintenant.
        """
        try:
            cache_key = f"luna:conversation:{user_id}"
            conversation_history = await redis_cache.get("conversation", user_id)
            
            if not conversation_history:
                return "[NOUVELLE CONVERSATION] Pas d'historique pr√©c√©dent."
            
            # Formater les derniers messages
            recent_messages = conversation_history[-limit:] if len(conversation_history) > limit else conversation_history
            
            formatted_history = []
            for msg in recent_messages:
                timestamp = msg.get('timestamp', 'R√©cent')
                role = "üë§ User" if msg.get('role') == 'user' else "üåô Luna"
                message = msg.get('message', '')[:100]  # Tronquer pour pas surcharger
                formatted_history.append(f"{role}: {message}")
            
            history_text = '\n'.join(formatted_history)
            
            logger.info("Conversation memory loaded", 
                       user_id=user_id, messages_count=len(recent_messages))
            
            return f"""[HISTORIQUE CONVERSATION R√âCENTE]
{history_text}

IMPORTANT: Tu as d√©j√† interagi avec cet utilisateur. √âvite de r√©p√©ter les m√™mes informations (sessions, plan, onboarding). Continue la conversation naturellement."""
            
        except Exception as e:
            logger.error("Error loading conversation memory", user_id=user_id, error=str(e))
            return "[NOUVELLE CONVERSATION] Historique non disponible."
    
    async def _get_conversation_state(self, user_id: str) -> Dict[str, Any]:
        """
        üé≠ SPRINT 2: R√©cup√®re l'√©tat de la conversation
        √âvite les boucles r√©p√©titives et adapte le comportement Luna
        """
        try:
            cache_key = f"luna:state:{user_id}"
            state = await redis_cache.get("state", user_id)
            
            if not state:
                # Nouvel utilisateur : √©tat par d√©faut
                return {
                    "phase": "greeting",  # greeting, exploring, action_mode, follow_up
                    "last_topic": None,
                    "actions_proposed": 0,
                    "user_engagement": "new",  # new, active, returning
                    "onboarding_done": False
                }
            
            return state
            
        except Exception as e:
            logger.error("Error loading conversation state", user_id=user_id, error=str(e))
            return {"phase": "greeting", "onboarding_done": False}
    
    async def _update_conversation_state(self, user_id: str, user_message: str, luna_response: str):
        """
        üé≠ Met √† jour l'√©tat conversationnel selon l'interaction
        """
        try:
            current_state = await self._get_conversation_state(user_id)
            
            # Analyser l'intention du message user
            user_msg = user_message.lower().strip()
            
            # D√©tection des patterns pour ajuster l'√©tat
            if any(pattern in user_msg for pattern in ["salut", "bonjour", "hello"]):
                if current_state["onboarding_done"]:
                    current_state["phase"] = "returning"
                else:
                    current_state["phase"] = "greeting"
            
            elif any(pattern in user_msg for pattern in ["go", "oui", "d'accord", "fait", "fais"]):
                current_state["phase"] = "action_mode"
                current_state["user_engagement"] = "active"
            
            elif any(pattern in user_msg for pattern in ["optimise", "analyse", "√©cris", "g√©n√®re"]):
                current_state["phase"] = "action_mode"
                current_state["last_topic"] = "action_request"
            
            elif any(pattern in user_msg for pattern in ["comment", "pourquoi", "c'est quoi"]):
                current_state["phase"] = "exploring"
            
            # Marquer onboarding comme fait apr√®s premi√®re vraie interaction
            if not current_state["onboarding_done"] and len(user_msg) > 5:
                current_state["onboarding_done"] = True
            
            # Compter les actions propos√©es (d√©tection dans r√©ponse Luna)
            if "action" in luna_response.lower() or "puis-je" in luna_response.lower():
                current_state["actions_proposed"] = current_state.get("actions_proposed", 0) + 1
            
            # Sauvegarder avec TTL 24h
            cache_key = f"luna:state:{user_id}"
            await redis_cache.set("state", user_id, current_state, ttl=86400)
            
            logger.info("Conversation state updated", 
                       user_id=user_id, phase=current_state["phase"])
            
        except Exception as e:
            logger.error("Error updating conversation state", user_id=user_id, error=str(e))
    
    def _build_sentiment_adaptation(self, sentiment_context: Optional[Dict] = None) -> str:
        """
        üé≠ SPRINT 3: Construit l'adaptation comportementale selon le sentiment
        """
        if not sentiment_context:
            return "Adapte ton ton selon le contexte √©motionnel de l'utilisateur."
        
        sentiment = sentiment_context.get("primary_sentiment", "neutre")
        confidence = sentiment_context.get("confidence", 0.0)
        energy_level = sentiment_context.get("energy_level", "medium")
        communication_style = sentiment_context.get("communication_style", "neutre")
        
        adaptations = {
            "motiv√©": """
üî• UTILISATEUR MOTIV√â (confiance: {confidence})
- Ton: Enthousiaste et √©nergique, match son √©nergie
- Langage: "Parfait !", "C'est parti !", "On fonce !", "Tu vas cartonner !"
- Actions: Propose des d√©fis, des √©tapes concr√®tes, alimente sa motivation
- Style: Direct et action-oriented, moins d'explications, plus d'actions
- √âmojis: üöÄ, üî•, ‚ö°, üéØ, üí™
            """,
            
            "anxieux": """
üòå UTILISATEUR ANXIEUX (confiance: {confidence})
- Ton: Rassurant et p√©dagogique, d√©compose les √©tapes
- Langage: "Pas de panique", "On va y aller √©tape par √©tape", "Je suis l√† pour t'accompagner"
- Actions: Propose des petites √©tapes, rassure sur la faisabilit√©
- Style: Explications d√©taill√©es, exemples concrets, support √©motionnel
- √âmojis: ü§ó, üíô, ‚úÖ, üåü, üéà
            """,
            
            "factuel": """
üìä UTILISATEUR FACTUEL (confiance: {confidence})
- Ton: Pr√©cis et structur√©, donn√©es concr√®tes
- Langage: "Voici les √©tapes", "Concr√®tement", "Les donn√©es montrent"
- Actions: Structure tes r√©ponses, utilise des listes, donne des m√©triques
- Style: Logique, m√©thodique, preuves et arguments
- √âmojis: üìä, üìã, ‚úÖ, üéØ, üìà
            """,
            
            "curieux": """
üîç UTILISATEUR CURIEUX (confiance: {confidence})
- Ton: P√©dagogique et exploratoire
- Langage: "Tu sais quoi ?", "D√©couvrons ensemble", "Voici pourquoi"
- Actions: Explique les "pourquoi", propose d'explorer diff√©rentes options
- Style: Questions ouvertes, encourage l'exploration
- √âmojis: ü§î, üí°, üîç, ‚ú®, üéì
            """
        }
        
        base_adaptation = adaptations.get(sentiment, "Adapte ton ton selon le contexte utilisateur.")
        
        # Ajustement selon niveau d'√©nergie
        if energy_level == "high":
            energy_note = "\n‚ö° √âNERGIE HAUTE: Utilise plus d'emojis, phrases courtes et percutantes !"
        elif energy_level == "low":
            energy_note = "\nüòå √âNERGIE BASSE: Ton plus calme, phrases rassurantes, √©vite le trop d'enthousiasme."
        else:
            energy_note = ""
        
        return base_adaptation.format(confidence=f"{confidence:.1f}") + energy_note
    
    def _build_empathy_context(self, sentiment_context: Optional[Dict] = None) -> str:
        """
        üíô SPRINT 3: Construit le contexte d'empathie selon les patterns d√©tect√©s
        """
        if not sentiment_context:
            return "Montre de l'empathie selon le contexte √©motionnel."
        
        keywords = sentiment_context.get("keywords_detected", [])
        emotional_state = sentiment_context.get("emotional_state", "neutral")
        
        empathy_responses = {
            "positive": "L'utilisateur semble positif, encourage cette dynamique !",
            "negative": "L'utilisateur semble frustr√© ou d√©√ßu, sois particuli√®rement bienveillant.",
            "neutral": "Contexte neutre, adapte selon ses besoins sp√©cifiques."
        }
        
        base_empathy = empathy_responses.get(emotional_state, "Reste empathique et √† l'√©coute.")
        
        # Empathie selon mots-cl√©s d√©tect√©s
        empathy_keywords = []
        if any(word in keywords for word in ["peur", "anxieux", "inquiet", "stress√©"]):
            empathy_keywords.append("ü§ó Rassure et d√©stresse l'utilisateur")
        
        if any(word in keywords for word in ["perdu", "compliqu√©", "difficile"]):
            empathy_keywords.append("üß≠ Guide avec des √©tapes simples")
            
        if any(word in keywords for word in ["motiv√©", "go", "fonce", "h√¢te"]):
            empathy_keywords.append("üöÄ Alimente et canalise cette motivation")
        
        keyword_context = " - " + " - ".join(empathy_keywords) if empathy_keywords else ""
        
        return base_empathy + keyword_context
    
    async def _get_conversation_history_for_sentiment(self, user_id: str) -> List[Dict]:
        """
        üåÄ SPRINT 3: R√©cup√®re l'historique pour l'analyse de sentiment
        Format sp√©cifique pour le SentimentAnalyzer
        """
        try:
            cache_key = f"luna:conversation:{user_id}"
            conversation_history = await redis_cache.get("conversation", user_id)
            
            if not conversation_history:
                return []
            
            # R√©cup√©rer les 5 derniers messages utilisateur
            user_messages = []
            for msg in reversed(conversation_history[-10:]):  # Regarder les 10 derniers messages
                if msg.get('role') == 'user':
                    user_messages.append({
                        'message': msg.get('message', ''),
                        'role': 'user',
                        'timestamp': msg.get('timestamp')
                    })
                if len(user_messages) >= 5:  # Limiter √† 5 pour l'analyse
                    break
            
            return list(reversed(user_messages))  # Remettre dans l'ordre chronologique
            
        except Exception as e:
            logger.error("Error loading conversation history for sentiment", user_id=user_id, error=str(e))
            return []
    
    def _build_progress_context(self, progress_profile) -> str:
        """
        üìà SPRINT 4: Construit le contexte de progression pour encouragements intelligents
        """
        if not progress_profile or not progress_profile.metrics:
            return """# [üìà BOUCLE PROGRESSION]
Utilisateur sans historique de progression d√©taill√©.
Encourage √† commencer son parcours d'optimisation !"""
        
        # R√©cup√©rer les achievements et zones √† am√©liorer
        achievements = progress_profile.get_top_achievements(limit=2)
        encouragement_areas = progress_profile.get_encouragement_areas(limit=2)
        
        # Construire le contexte selon tendance globale
        trend_contexts = {
            "breakthrough": """üöÄ UTILISATEUR EN PERC√âE MAJEURE !
- Momentum exceptionnel: {momentum_score:.0f}/100
- Derni√®re victoire: {last_victory}
- Ton: C√©l√®bre ses succ√®s, alimente cette dynamique fantastique !
- Actions: Propose d√©fis plus ambitieux, capitalise sur son √©lan""",
            
            "rising": """üìà UTILISATEUR EN PROGRESSION !
- Momentum positif: {momentum_score:.0f}/100  
- Progr√®s r√©cents: {achievements}
- Ton: Encourageant et motivant, renforce les habitudes gagnantes
- Actions: Consolide ses gains, propose next level""",
            
            "stable": """‚û°Ô∏è UTILISATEUR STABLE
- Momentum √©quilibr√©: {momentum_score:.0f}/100
- Ton: Bienveillant, identifie opportunit√©s d'acc√©l√©ration  
- Actions: Stimule avec nouveaux challenges, √©vite la stagnation""",
            
            "declining": """üìâ UTILISATEUR EN BAISSE
- Momentum ralenti: {momentum_score:.0f}/100
- Zones de pr√©occupation: {encouragement_areas}
- Ton: Empathique et remotivant, pas culpabilisant !
- Actions: Redonne confiance, propose petites victoires faciles""",
            
            "stagnant": """üò¥ UTILISATEUR STAGNANT  
- Momentum faible: {momentum_score:.0f}/100
- Ton: R√©veille l'ambition doucement, trouve ce qui bloque
- Actions: Micro-actions, rebuild momentum step by step"""
        }
        
        base_context = trend_contexts.get(progress_profile.overall_trend.value, trend_contexts["stable"])
        
        # Injections dynamiques
        last_victory_text = "Aucune victoire r√©cente" 
        if progress_profile.last_victory:
            victory = progress_profile.last_victory
            last_victory_text = f"{victory['improvement']:+.1f} {victory.get('unit', 'points')} en {victory['metric_type']}"
        
        achievements_text = "√Ä d√©velopper"
        if achievements:
            achievements_text = ", ".join([f"+{a['improvement']:.1f} {a['type']}" for a in achievements])
        
        encouragement_text = "Toutes les m√©triques sont stables"
        if encouragement_areas:
            encouragement_text = ", ".join([f"{a['type']} ({a['decline']:.1f} en baisse)" for a in encouragement_areas])
        
        # Next milestone
        next_milestone_text = "D√©finir prochains objectifs"
        if progress_profile.next_milestone:
            milestone = progress_profile.next_milestone
            next_milestone_text = f"{milestone['target']} (√ânergie: {milestone.get('estimated_energy', '?')}‚ö°)"
        
        formatted_context = base_context.format(
            momentum_score=progress_profile.momentum_score,
            last_victory=last_victory_text,
            achievements=achievements_text,
            encouragement_areas=encouragement_text
        )
        
        return f"""# [üìà BOUCLE PROGRESSION]
Tendance globale: {progress_profile.overall_trend.value.upper()}
{formatted_context}

üéØ PROCHAIN MILESTONE: {next_milestone_text}

‚ö†Ô∏è R√àGLE PROGRESSION: Adapte tes encouragements selon cette analyse !
Si tendance positive ‚Üí C√©l√®bre et challenge  
Si tendance n√©gative ‚Üí Rassure et relance"""
    
    def _build_vision_context(self, vision_profile, current_message: str) -> str:
        """
        üéØ SPRINT 5: Construit le contexte de vision long terme et storytelling
        """
        if not vision_profile or not vision_profile.career_narrative:
            return """# [üéØ BOUCLE NARRATIVE]
Utilisateur sans vision long terme d√©finie.
Aide-le √† clarifier ses objectifs de carri√®re !"""
        
        narrative = vision_profile.career_narrative
        primary_goal = vision_profile.get_primary_goal()
        
        # D√©tection de l'action actuelle pour connexion narrative
        current_action = self._detect_current_action(current_message)
        story_connection = vision_profile.get_story_connection(current_action) if primary_goal else ""
        
        # Construction du contexte selon phase de carri√®re
        phase_contexts = {
            "discovery": """üîç UTILISATEUR EN D√âCOUVERTE
- Phase: Exploration et construction identit√© professionnelle
- Ton: Guide bienveillant, aide √† clarifier la vision
- Actions: Propose exploration secteurs, tests comp√©tences, d√©couverte passions""",
            
            "growth": """üìà UTILISATEUR EN CROISSANCE  
- Phase: D√©veloppement expertise et mont√©e comp√©tences
- Ton: Coach performance, alimente l'ambition d'excellence
- Actions: Propose d√©fis comp√©tences, optimisations CV, strat√©gies progression""",
            
            "acceleration": """üöÄ UTILISATEUR EN ACC√âL√âRATION
- Phase: Leadership et influence √©largie
- Ton: Conseiller strat√©gique, vision haut niveau
- Actions: Propose responsabilit√©s accrues, mentorat, impact organisation""",
            
            "transition": """üîÑ UTILISATEUR EN TRANSITION
- Phase: R√©invention et nouveau chapitre professionnel  
- Ton: Accompagnateur du changement, rassure sur capacit√© adaptation
- Actions: Valorise exp√©rience pass√©e, bridge vers nouveau domaine""",
            
            "mastery": """üëë UTILISATEUR EXPERT
- Phase: Ma√Ætrise et transmission  
- Ton: Partenaire de r√©flexion, d√©fis intellectuels
- Actions: Propose mentorat, innovation, cr√©ation valeur unique"""
        }
        
        phase_context = phase_contexts.get(narrative.career_phase.value, phase_contexts["growth"])
        
        # Construction contexte complet
        goal_context = ""
        if primary_goal:
            progress_indicator = "üéØ" if primary_goal.progress_percentage >= 50 else "üèÉ" if primary_goal.progress_percentage >= 25 else "üå±"
            goal_context = f"""
üéØ OBJECTIF PRINCIPAL ACTIF:
{primary_goal.title} ({primary_goal.progress_percentage:.0f}% accompli {progress_indicator})
Timeline: {primary_goal.target_timeline}
Motivation: {primary_goal.why_statement if primary_goal.why_statement else "√âvolution professionnelle"}"""
        
        # Storytelling motivationnel
        motivational_story = ""
        if narrative.current_chapter and narrative.transformation_theme:
            motivational_story = f"""
üìñ NARRATIVE PERSONNELLE:
Histoire actuelle: {narrative.current_chapter}
Th√®me de transformation: {narrative.transformation_theme}
Prochain arc: {narrative.next_story_arc}"""
        
        # Connexion action ‚Üí vision
        action_connection = ""
        if story_connection and current_action != "conversation g√©n√©rale":
            action_connection = f"""
üîó CONNEXION NARRATIVE:
{story_connection}
‚Üí IMPORTANT: Mentionne cette connexion dans ta r√©ponse pour donner du sens !"""
        
        return f"""# [üéØ BOUCLE NARRATIVE]
Phase carri√®re: {narrative.career_phase.value.upper()}
Vision momentum: {vision_profile.vision_momentum:.0f}/100
Coh√©rence story: {vision_profile.story_coherence_score:.0f}/100

{phase_context}
{goal_context}
{motivational_story}
{action_connection}

‚ö†Ô∏è R√àGLE NARRATIVE: Connecte chaque conseil √† la vision long terme !
Transforme les actions en √©tapes vers ses r√™ves professionnels."""
    
    def _detect_current_action(self, message: str) -> str:
        """D√©tecte l'action actuelle depuis le message pour connexion narrative"""
        
        message_lower = message.lower().strip()
        
        action_patterns = {
            "optimisation cv": ["cv", "optimise", "am√©liore mon cv", "booster mon profil"],
            "r√©daction lettre": ["lettre", "candidature", "postule", "√©cris une lettre"],
            "recherche emploi": ["offre", "poste", "job", "emploi", "candidater", "postuler"],
            "pr√©paration entretien": ["entretien", "interview", "pr√©pare", "questions"],
            "d√©veloppement r√©seau": ["r√©seau", "networking", "linkedin", "contacts"],
            "√©valuation comp√©tences": ["comp√©tences", "skills", "√©value", "bilan"],
            "strat√©gie carri√®re": ["carri√®re", "√©volution", "progression", "objectifs"]
        }
        
        for action, patterns in action_patterns.items():
            if any(pattern in message_lower for pattern in patterns):
                return action
        
        return "conversation g√©n√©rale"

    async def _save_conversation_turn(self, user_id: str, user_message: str, luna_response: str):
        """
        üíæ Sauvegarde le tour de conversation pour la m√©moire
        """
        try:
            cache_key = f"luna:conversation:{user_id}"
            
            # R√©cup√©rer historique existant
            conversation_history = await redis_cache.get_json(cache_key) or []
            
            # Ajouter les nouveaux messages
            timestamp = datetime.now(timezone.utc).isoformat()
            
            conversation_history.append({
                "role": "user",
                "message": user_message,
                "timestamp": timestamp
            })
            
            conversation_history.append({
                "role": "luna", 
                "message": luna_response,
                "timestamp": timestamp
            })
            
            # Garder seulement les 20 derniers messages (10 tours)
            if len(conversation_history) > 20:
                conversation_history = conversation_history[-20:]
            
            # Sauvegarder avec TTL de 24h
            await redis_cache.set("conversation", user_id, conversation_history, ttl=86400)
            
            logger.info("Conversation turn saved", 
                       user_id=user_id, total_messages=len(conversation_history))
            
        except Exception as e:
            logger.error("Error saving conversation turn", user_id=user_id, error=str(e))

    def _build_state_guidance(self, conversation_state: Dict[str, Any]) -> str:
        """
        üé≠ SPRINT 2: Guide le comportement Luna selon l'√©tat conversationnel
        Casse les boucles r√©p√©titives !
        """
        phase = conversation_state.get("phase", "greeting")
        onboarding_done = conversation_state.get("onboarding_done", False)
        actions_proposed = conversation_state.get("actions_proposed", 0)
        
        guidance_map = {
            "greeting": """[MODE ACCUEIL]
Si c'est la premi√®re fois : Accueil chaleureux mais bref.
Si utilisateur r√©current : "Content de te revoir !" et continue la conversation.""",
            
            "returning": """[MODE RETOUR]  
L'utilisateur revient. PAS de re-onboarding ! Salue bri√®vement et demande comment tu peux aider aujourd'hui.""",
            
            "action_mode": """[MODE ACTION]
L'utilisateur veut passer √† l'action (dit "go", "oui", "fais"). 
ARR√äTE les propositions, AGIS ! Demande les d√©tails n√©cessaires et commence le travail.""",
            
            "exploring": """[MODE EXPLORATION]
L'utilisateur explore (pose des questions). R√©ponds clairement, puis propose naturellement des actions pertinentes."""
        }
        
        base_guidance = guidance_map.get(phase, guidance_map["greeting"])
        
        # Ajustements selon historique
        if onboarding_done:
            base_guidance += "\nONBOARDING D√âJ√Ä FAIT: Ne r√©p√®te pas les informations de base."
        
        if actions_proposed > 2:
            base_guidance += "\nASSEZ D'ACTIONS PROPOS√âES: L'utilisateur conna√Æt tes capacit√©s. Sois plus direct."
        
        return f"""[GUIDANCE COMPORTEMENTALE]
Phase conversation: {phase}
{base_guidance}

R√àGLE OR: Si utilisateur dit une action directe ("optimise mon CV"), ne propose plus de menu, FAIS-LE !"""

    def _get_context_prompt(self, app_context: str) -> str:
        """G√©n√®re le contexte sp√©cifique selon l'application"""
        contexts = {
            "cv": """
[CONTEXTE CV] : L'utilisateur est dans Phoenix CV. Tu es son experte en optimisation CV et strat√©gie carri√®re. Focus sur : scores ATS, valorisation comp√©tences, structure CV, keywords sectoriels. Tes r√©ponses doivent √™tre structur√©es avec des m√©triques concr√®tes.""",
            
            "letters": """
[CONTEXTE LETTERS] : L'utilisateur est dans Phoenix Letters. Tu es son experte en lettres de motivation percutantes. Focus sur : personnalisation entreprise, storytelling convaincant, diff√©renciation candidats, analyse offres d'emploi.""",
            
            "website": """
[CONTEXTE WEBSITE] : L'utilisateur est sur le site principal Phoenix. Tu es son guide strat√©gique global. Focus sur : vision carri√®re, choix d'outils, planification parcours, optimisation √©nergie Luna."""
        }
        return contexts.get(app_context, contexts["website"])

    async def _get_user_context_packet(self, user_id: str) -> str:
        """R√©cup√®re le Context Packet structur√© de l'utilisateur"""
        try:
            # G√©n√©ration du Context Packet via Narrative Analyzer
            context_packet = await narrative_analyzer.generate_context_packet(user_id)
            
            # Formatage pour injection dans le prompt Luna
            context_json = json.dumps(context_packet.to_dict(), indent=2, ensure_ascii=False)
            
            return f"""[CONTEXTE NARRATIF STRUCTUR√â]
Donn√©es analytiques utilisateur g√©n√©r√©es par le Narrative Analyzer v1.5 :

{context_json}

INSTRUCTIONS D'USAGE CONTEXTE :
- Si user.plan == "unlimited" ‚Üí Mentionne √©nergie illimit√©e üåô
- Si usage.last_activity_hours > 48 ‚Üí Ton accueillant "Content de te revoir"
- Si progress.ats_delta_pct_14d > 0 ‚Üí F√©licite les progr√®s
- Si last_emotion_or_doubt pr√©sent ‚Üí Aborde subtilement le doute
- Si usage.session_count_7d > 5 ‚Üí Utilisateur motiv√©, propose actions avanc√©es
- Adapte TES suggestions selon progress.letters_target (secteur cibl√©)"""
            
        except Exception as e:
            logger.error("Error generating context packet", user_id=user_id, error=str(e))
            return "[CONTEXTE NARRATIF] : Nouvel utilisateur - Analyse en cours de g√©n√©ration."

    async def generate_response(
        self, 
        user_id: str,
        message: str,
        app_context: str = "website",
        user_name: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        G√©n√®re une r√©ponse Luna avec personnalit√© unifi√©e
        
        Args:
            user_id: ID de l'utilisateur
            message: Message de l'utilisateur
            app_context: Contexte app (cv, letters, website)
            user_name: Pr√©nom utilisateur (optionnel)
        """
        try:
            # 0. üîë S'assurer que Gemini est configur√© avec cl√© API valide
            await self._ensure_genai_configured()
            
            # 1. üåÄ SPRINT 3: Analyse du sentiment utilisateur pour adaptation comportementale
            sentiment_analysis = await sentiment_analyzer.analyze_user_message(
                message=message,
                user_id=user_id,
                conversation_history=await self._get_conversation_history_for_sentiment(user_id)
            )
            
            # 2. üìà SPRINT 4: R√©cup√©ration du profil de progression + c√©l√©brations
            progress_profile = await progress_tracker.get_user_progress_profile(user_id)
            
            # 2.1. üéØ SPRINT 5: R√©cup√©ration du profil de vision long terme
            vision_profile = await vision_tracker.get_user_vision_profile(user_id)
            
            # 2.2. V√©rification si c√©l√©bration automatique n√©cessaire
            celebration = None
            if celebration_engine.should_trigger_celebration(progress_profile):
                achievements = progress_profile.get_top_achievements(limit=1)
                if achievements:
                    top_achievement = achievements[0]
                    from app.core.progress_tracker import ProgressMetricType, ProgressTrend
                    
                    celebration = celebration_engine.generate_celebration(
                        metric_type=ProgressMetricType(top_achievement["type"]),
                        improvement=top_achievement["improvement"],
                        trend=ProgressTrend(top_achievement["trend"]),
                        user_sentiment=sentiment_analysis.primary_sentiment
                    )
            
            # 3. Construction du prompt unifi√© avec Context Packet + M√âMOIRE + √âTAT + SENTIMENT + PROGRESSION
            core_prompt = self._build_luna_core_prompt(sentiment_context=sentiment_analysis.to_dict())
            context_prompt = self._get_context_prompt(app_context)
            context_packet = await self._get_user_context_packet(user_id)
            conversation_memory = await self._get_conversation_memory(user_id)
            conversation_state = await self._get_conversation_state(user_id)
            progress_context = self._build_progress_context(progress_profile)
            vision_context = self._build_vision_context(vision_profile, message)
            
            # 4. Assemblage dynamique avec INTELLIGENCE CONVERSATIONNELLE
            state_guidance = self._build_state_guidance(conversation_state)
            
            full_prompt = f"""{core_prompt}

{context_prompt}

{context_packet}

{conversation_memory}

{state_guidance}

{progress_context}

{vision_context}

{f"# [üéä C√âL√âBRATION AUTOMATIQUE]{chr(10)}{celebration_engine.format_celebration_for_luna(celebration)}" if celebration else ""}

# [üåÄ ANALYSE SENTIMENT TEMPS R√âEL]
Sentiment d√©tect√© : {sentiment_analysis.primary_sentiment} (confiance: {sentiment_analysis.confidence:.1f})
√âtat √©motionnel : {sentiment_analysis.emotional_state}
Style communication : {sentiment_analysis.communication_style}
Niveau d'√©nergie : {sentiment_analysis.energy_level}
Mots-cl√©s d√©tect√©s : {', '.join(sentiment_analysis.keywords_detected[:3])}

‚ö†Ô∏è IMPORTANT : Adapte imp√©rativement ton TON et STYLE selon cette analyse !

# [CONVERSATION ACTUELLE]
{"Utilisateur " + user_name + ": " if user_name else "Utilisateur: "}{message}

Luna, r√©ponds selon ta personnalit√© unifi√©e en tenant compte de ton contexte et du Capital Narratif :"

# [R√âPONSE ATTENDUE]
G√©n√®re une r√©ponse personnalis√©e Luna qui :
- Fait r√©f√©rence √† l'historique si pertinent
- Propose 2-3 actions concr√®tes
- Mentionne les co√ªts √©nerg√©tiques si applicable
- Termine par une question de suivi
"""

            # 5. G√©n√©ration avec Gemini + FALLBACK
            try:
                response = self.model.generate_content(full_prompt)
                
                if not response or not response.text:
                    raise Exception("Empty response from Gemini")
                    
            except Exception as gemini_error:
                logger.error("Gemini API failed, using fallback", error=str(gemini_error))
                
                # üö® FALLBACK: R√©ponse intelligente selon le message
                fallback_response = self._generate_fallback_response(message, sentiment_analysis)
                
                # Simuler un objet response
                class FallbackResponse:
                    def __init__(self, text):
                        self.text = text
                        
                response = FallbackResponse(fallback_response)
            
            if not response or not response.text:
                return {
                    "success": False,
                    "message": "üåô D√©sol√©, j'ai des difficult√©s techniques. Peux-tu reformuler ?",
                    "context": app_context,
                    "energy_consumed": 0,
                    "type": "error"
                }

            # üåô LUNA V2: Classification intelligente conversation vs action
            action_name = self._calculate_intelligent_energy_cost(message, response.text.strip())
            
            # üí∞ D√âDUCTION R√âELLE √âNERGIE UTILISATEUR
            energy_consumed = 0
            if action_name != "luna_conversation":  # Seulement si pas gratuit
                try:
                    result = await energy_manager.consume(
                        user_id=user_id,
                        action_name=action_name,
                        context={
                            "app_source": app_context,
                            "message_preview": message[:50],
                            "response_preview": response.text.strip()[:50],
                            "sentiment": sentiment_analysis.primary_sentiment,
                            "action_type": "luna_chat"
                        }
                    )
                    
                    # R√©cup√©rer l'√©nergie r√©ellement consomm√©e
                    energy_consumed = result.get("energy_consumed", 0)
                    logger.info("Energy consumed successfully", 
                               user_id=user_id, 
                               action=action_name, 
                               energy_consumed=energy_consumed,
                               unlimited=result.get("unlimited", False))
                
                except Exception as e:
                    # Gestion des erreurs (√©nergie insuffisante, etc.)
                    error_msg = str(e)
                    logger.warning("Energy consumption failed", 
                                  user_id=user_id, 
                                  action=action_name, 
                                  error=error_msg)
                    
                    # D√©terminer le type d'erreur
                    if "insuffisant" in error_msg.lower() or "insufficient" in error_msg.lower():
                        return {
                            "success": False,
                            "message": "‚ö° √ânergie insuffisante pour cette action. Recharge ton compte pour continuer !",
                            "context": app_context,
                            "energy_consumed": 0,
                            "type": "insufficient_energy",
                            "action_requested": action_name
                        }
                    else:
                        # Autres erreurs - permettre l'action mais log l'erreur
                        logger.error("Energy system error - allowing action", 
                                    user_id=user_id, action=action_name, error=error_msg)
                        energy_consumed = 0  # Gratuit en cas d'erreur syst√®me
            
            # üéä BONUS √âNERGIE pour c√©l√©brations
            energy_bonus_awarded = 0
            if celebration and celebration.energy_bonus > 0:
                try:
                    bonus_result = await energy_manager.refund(
                        user_id=user_id,
                        amount=celebration.energy_bonus,
                        reason=f"Luna celebration bonus - {celebration.level.value}",
                        context={
                            "celebration_level": celebration.level.value,
                            "achievement": celebration.achievement_description,
                            "app_source": app_context,
                            "bonus_type": "celebration"
                        }
                    )
                    
                    energy_bonus_awarded = celebration.energy_bonus
                    logger.info("Energy bonus awarded", 
                               user_id=user_id, 
                               bonus_amount=celebration.energy_bonus,
                               celebration_level=celebration.level.value,
                               transaction_id=bonus_result.get("transaction_id"))
                
                except Exception as e:
                    logger.error("Failed to award energy bonus", 
                                user_id=user_id, 
                                bonus_amount=celebration.energy_bonus,
                                error=str(e))
                    # Continuer m√™me si le bonus √©choue
            
            # üß† SPRINT 2: Sauvegarder la conversation + √âtat pour intelligence
            await self._save_conversation_turn(user_id, message, response.text.strip())
            await self._update_conversation_state(user_id, message, response.text.strip())
            
            # üåÄ SPRINT 3+4+5: Logs complets des 3 boucles Luna
            logger.info("üåô Luna Triple Loop Analysis",
                       user_id=user_id,
                       # Boucle Comportementale
                       sentiment=sentiment_analysis.primary_sentiment,
                       emotional_state=sentiment_analysis.emotional_state,
                       energy_level=sentiment_analysis.energy_level,
                       # Boucle Progression  
                       progress_trend=progress_profile.overall_trend.value,
                       momentum_score=f"{progress_profile.momentum_score:.0f}/100",
                       celebration_triggered=celebration is not None,
                       # Boucle Narrative
                       career_phase=vision_profile.career_narrative.career_phase.value,
                       vision_momentum=f"{vision_profile.vision_momentum:.0f}/100",
                       primary_goal=vision_profile.get_primary_goal().title if vision_profile.get_primary_goal() else "None")
            
            return {
                "success": True,
                "message": response.text.strip(),
                "context": app_context,
                "energy_consumed": energy_consumed,  # üí∞ Real energy deducted from user account
                "type": "text",
                # üåÄ SPRINT 3: Donn√©es comportementales pour monitoring
                "sentiment_analysis": {
                    "primary_sentiment": sentiment_analysis.primary_sentiment,
                    "confidence": sentiment_analysis.confidence,
                    "energy_level": sentiment_analysis.energy_level,
                    "communication_style": sentiment_analysis.communication_style,
                    "emotional_state": sentiment_analysis.emotional_state,
                    "keywords": sentiment_analysis.keywords_detected[:3]  # Top 3 pour √©viter surcharge
                },
                # üìà SPRINT 4: Donn√©es de progression pour celebrations  
                "progress_analysis": {
                    "overall_trend": progress_profile.overall_trend.value,
                    "momentum_score": progress_profile.momentum_score,
                    "recent_achievements": progress_profile.get_top_achievements(limit=2),
                    "last_victory": progress_profile.last_victory,
                    "next_milestone": progress_profile.next_milestone,
                    "celebration_triggered": celebration is not None,
                    "celebration_level": celebration.level.value if celebration else None,
                    "energy_bonus_awarded": energy_bonus_awarded
                },
                # üéØ SPRINT 5: Donn√©es de vision et narrative
                "vision_analysis": {
                    "career_phase": vision_profile.career_narrative.career_phase.value,
                    "vision_momentum": vision_profile.vision_momentum,
                    "story_coherence": vision_profile.story_coherence_score,
                    "primary_goal": vision_profile.get_primary_goal().title if vision_profile.get_primary_goal() else None,
                    "transformation_theme": vision_profile.career_narrative.transformation_theme,
                    "current_chapter": vision_profile.career_narrative.current_chapter,
                    "motivational_triggers": vision_profile.motivational_triggers[:2]  # Top 2
                }
            }
            
        except Exception as e:
            logger.error("Luna Core generation error", user_id=user_id, error=str(e))
            return {
                "success": False,
                "message": "üåô J'ai rencontr√© un probl√®me technique. R√©essaie dans quelques instants !",
                "context": app_context,
                "energy_consumed": 0,
                "type": "error"
            }

    def _generate_fallback_response(self, message: str, sentiment_analysis) -> str:
        """
        üö® FALLBACK: G√©n√®re une r√©ponse d'urgence si Gemini est down
        """
        
        message_lower = message.lower()
        sentiment = sentiment_analysis.primary_sentiment if sentiment_analysis else "neutre"
        
        # R√©ponses contextuelles selon le type de message
        if any(word in message_lower for word in ["salut", "bonjour", "hello", "hey"]):
            return "üåô Salut ! Je suis Luna, ton copilote carri√®re. Comment puis-je t'aider aujourd'hui ? (‚ö° Maintenance en cours, d√©sol√© pour la r√©ponse basique !)"
            
        elif any(word in message_lower for word in ["cv", "curriculum"]):
            return "üéØ Je peux t'aider avec ton CV ! Malheureusement je suis en maintenance technique. Peux-tu r√©essayer dans quelques minutes ? En attendant, pense √† optimiser tes mots-cl√©s ! ‚ú®"
            
        elif any(word in message_lower for word in ["lettre", "motivation"]):
            return "üìù Les lettres de motivation sont ma sp√©cialit√© ! Je suis temporairement en maintenance. R√©essaie bient√¥t, et on va cr√©er une lettre qui cartonne ! üöÄ"
            
        elif any(word in message_lower for word in ["conseil", "aide", "suggestion"]):
            return "üí° Je suis l√† pour t'accompagner ! Actuellement en maintenance technique. En attendant : reste focus sur tes objectifs et reviens me voir dans quelques minutes ! üí™"
            
        elif sentiment == "anxieux":
            return "ü§ó Je sens que c'est un moment important pour toi. Je suis temporairement en maintenance, mais je serai bient√¥t de retour pour t'√©pauler comme il faut ! üíô"
            
        elif sentiment == "motiv√©":
            return "üöÄ J'adore ton √©nergie ! Je suis en maintenance rapide, mais √ßa va pas m'emp√™cher de revenir en force pour booster ta carri√®re ! √Ä tr√®s vite ! üî•"
            
        else:
            return "üåô Salut ! Je suis Luna, ton copilote carri√®re. Je suis temporairement en maintenance technique, mais je reviens tr√®s vite ! Peux-tu reformuler ta demande dans quelques minutes ? ‚ö°"

# Instance globale (lazy initialization)
luna_core = None

def get_luna_core():
    """R√©cup√®re l'instance Luna Core avec lazy initialization"""
    global luna_core
    if luna_core is None:
        luna_core = LunaCore()
    return luna_core